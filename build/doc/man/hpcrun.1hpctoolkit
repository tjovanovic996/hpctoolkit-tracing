'\" t
.\" Manual page created with latex2man on Thu Aug  8 13:41:15 CDT 2019
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "HPCRUN" "1" "2018/09/30" "The HPCToolkit Performance Tools " "The HPCToolkit Performance Tools "
.SH NAME

.PP
hpcrun
is profiling tool that collects call path profiles of program executions 
using statistical sampling of hardware counters, software counters, or timers. 
.PP
See \fIhpctoolkit\fP(1)
for an overview of \fBHPCToolkit\fP\&.
.PP
.SH SYNOPSIS

.PP
hpcrun
[\fBprofiling\-options\fP]
\fIcommand\fP
[\fBcommand\-arguments\fP]
.PP
hpcrun
[\fBinfo\-options\fP]
.PP
.SH DESCRIPTION

.PP
hpcrun
profiles the execution of an arbitrary command \fIcommand\fP
using statistical sampling. 
hpcrun
can profile an execution using multiple sample sources simultaneously, 
supports measurement of applications with multiple processes and/or multiple threads, and handles complex runtime behaviors including 
fork, exec, and/or dynamic loading of shared libraries. 
hpcrun
can be used in conjunction with program launchers such as mpiexec
and SLURM\&'s srun\&.
.PP
To profile a statically\-linked executable, make sure to link with \fIhpclink\fP(1)
\&.
.PP
To configure hpcrun\&'s
sampling sources, specify events and periods using the \-e/\-\-event
option. 
For an event \fIe\fP
and period \fIp\fP,
after every \fIp\fP
instances of \fIe\fP,
a sample is generated that causes hpcrun
to inspect the 
current calling context and augment its execution measurements of the monitored \fIcommand\fP\&.
.PP
If no sample source is specified, by default hpcrun
profile using the timer 
CPUTIME on Linux or WALLCLOCK on Blue Gene at a frequency of 200 samples per second per thread. 
.PP
When \fIcommand\fP
terminates, a profile measurement database will be written to the directory:
.br
.br
\fB \fP\fB \fP\fB \fPhpctoolkit\-\fIcommand\fP\-measurements[\-\fIjobid\fP]
.br
.br
where \fIjobid\fP
is a parallel job launcher id associated with the execution, if available. 
.PP
hpcrun
allows you to abort an execution and write the partial profiling data to disk by sending a signal such as SIGHUP or SIGINT 
(which is often bound to Control\-c). 
This can be extremely useful to collect data for long\-running or misbehaving applications. 
.PP
.SH ARGUMENTS

.PP
Default values for optional arguments are shown in {}\&. 
.PP
.SS COMMAND
.PP
.TP
\fIcommand\fP
 The command to profile. 
.PP
.TP
\fIcommand\-arguments\fP
 Arguments to the command to profile. 
.PP
.SS OPTIONS: INFORMATIONAL
.PP
.TP
\fB\-l\fP, \fB\-L\fP, \fB\-\-list\-events\fP
 List available events. (N.B.: some may not be profilable) 
.PP
.TP
\fB\-V\fP, \fB\-\-version\fP
 Print version information. 
.PP
.TP
\fB\-h\fP, \fB\-\-help\fP
 Print help. 
.PP
.SS OPTIONS: PROFILING
.PP
.TP
\fB\-ds\fP, \fB\-\-delay\-sampling\fP
 Don\&'t start sampling until the application enables sampling under program control. 
Use this option to measure specific intervals in an application\&'s execution by bracketing code 
regions where measurement is desired 
with calls to hpctoolkit_sampling_start()
and hpctoolkit_sampling_stop()\&.
Sampling may be started and stopped any number of times during an execution; 
measurements from all measurement intervals are aggregated. 
.PP
.TP
\fB\-e\fP \fIevent[@howoften]\fP, \fB\-\-event\fP \fIevent[@howoften]\fP
 \fIevent\fP
may be an architecture\-independent hardware or software event supported by Linux perf, a native hardware counter event, 
a hardware counter event supported by the PAPI library, a Linux system timer (CPUTIME
and REALTIME),
or the 
operating system interval timer WALLCLOCK\&.
This option may be given multiple times to profile several events at once. 
While events measured using the Linux perf monitoring infrastructure will be transparently multiplexed if necessary, 
for other sampling sources or on operating systems such as the Blue Gene Compute Node Kernel, 
there may be system\-dependent limits on how many events can be profiled simultaneously and on which events may be combined for profiling. 
If the value for \fIhowoften\fP
is a number, it will be interpreted as a sample period. 
For Linux perf events, one may specify a sampling frequency for \fIhowoften\fP
by writing f before a number. 
For instance, to sample an event 100 times per second, specify \fIhowoften\fP
as \&'@f100\&'\&. 
For Linux perf events, if no value for \fIhowoften\fP
is specified, hpcrun
will monitor the event using frequency\-based sampling at 300 samples/second. 
.RS
.TP
.B *
For timer events CPUTIME, REALTIME, and WALLCLOCK, the units for a sample period are microseconds.
.TP
.B *
Timer events should not be mixed with hardware events. 
.TP
.B *
See the ``Sample sources\&'' under \fBNOTES\fP for additional details.
.RE
.RS
.PP
.RE
.TP
\fB\-c\fP \fIhowoften\fP, \fB\-\-count\fP \fIhowoften\fP
 Only available for events managed by Linux perf. This option 
specifies a default value for how often to sample. The value for \fIhowoften\fP
may be a number that will be used as a default 
event period or an f followed by a number, e.g. f100, to specify a default sampling frequency in samples/second. 
.PP
By default, hpcrun
will allow attribution of hardware counter events to have arbitrary skid. 
Some processor architectures, e.g., ARM, don\&'t support attribution with any higher level of precision. 
If a processor does not support the specified level of attribution precision for a hardware counter event, 
hpcrun
may record 0 occurrences of the event without reporting an error. 
.PP
.TP
\fB\-f\fP \fIfrac\fP, \fB\-fp\fP \fIfrac\fP, \fB\-\-process\-fraction\fP \fIfrac\fP
 Measure only a fraction \fIfrac\fP
of the execution\&'s processes. 
For each process, enable measurement of each thread with probability \fIfrac\fP,
a real number or a fraction (1/10) between 0 and 1. 
To minimize perturbations, when measurement for a process is disabled 
all threads in a process still receive sampling interrupts but they are ignored. 
.PP
.TP
\fB\-lm\fP \fIsize\fP, \fB\-\-low\-memsize\fP \fIsize\fP
 Allocate an additional segment to store measurement data 
whenever free space in the current segment is less than the specified \fIsize\fP\&.
If not given, the default for \fIsize\fP
is 80K. 
.PP
.TP
\fB\-m\fP \fIswitch\fP, \fB\-\-merge\-threads\fP \fIswitch\fP
 Merge non\-overlapped threads into one virtual thread. 
This option is to reduce the number of generated 
profile and trace files as each thread generates its own 
profile and trace data. The options are: 
.RS
.TP
.B *
0 : do not merge non\-overlapped threads 
.TP
.B *
1 : merge non\-overlapped threads (default) 
.RE
.RS
.PP
.RE
.TP
\fB\-ms\fP \fIsize\fP, \fB\-\-memsize\fP \fIsize\fP
 Use the specified \fIsize\fP
as segment size when allocating memory for measurement data. 
The specified value is rounded up to a multiple of the `system page size. 
If not given, the default for \fIsize\fP
is 4M. 
.PP
.TP
\fB\-mp\fP \fIprob\fP, \fB\-\-memleak\-prob\fP \fIprob\fP
 Monitor a subset of memory allocations performed by the application to detect leaks. 
An allocation is a call to one of malloc,
calloc,
realloc,
etc 
and its matching call to free\&.
At each allocation HPCToolkit generates a pseudo\-random number in the range [0.0, 1.0) 
and monitors the allocation if the number is less than the value \fIprob\fP
specified here, 
The value may be written as a a floating point number or as a fraction. 
If not given, the default for \fIprob\fP
is 0.1. 
.PP
.TP
\fB\-o\fP \fIoutpath\fP, \fB\-\-output\fP \fIoutpath\fP
 Directory to receive output data. 
If not given, the default directory ia hpctoolkit\-<command>\-measurements[\-<jobid>]\&.
.RS
Caution: If no <jobid> is available and no output option is given, 
profiles from multiple runs of the same <command> will be placed into the same output directory, 
which may lead to confusing or incorrect analysis results. 
.RE
.RS
.PP
.RE
.TP
\fB\-r\fP, \fB\-\-retain\-recursion\fP
 Do not collapse simple recursive call chains. 
Normally as hpcrun
monitors an application that employs simple recursion, it collapses call chains of recursive calls to a single level. 
This design enables a user to see how the aggregate costs of recursion are associated with each recursive call yet 
saves space and time during post\-mortem analysis by collapsing long chains of recursive calls. 
If this option is given, hpcrun
will record all elements of a recursive call chain. 
Note: When you use the RETCNT
sample source this option is enabled automatically 
to gather accurate counts. 
.PP
.TP
\fB\-t\fP, \fB\-\-trace\fP
 Generate a call path trace in addition to a call path profile. 
.PP
.SS OPTIONS: HPCTOOLKIT DEVELOPMENT
.PP
These options are intended for use by the HPCToolkit team, 
but could be helpful to others interested in HPCToolkit\&'s implementation. 
\&. 
.PP
.TP
\fB\-d\fP, \fB\-\-debug\fP
 After initialization, spin wait until you attach a debugger 
to one or more of the application\&'s processes. 
After attaching you can set breakpoints or watchpoints in your application\&'s code 
or in HPCToolkit\&'s hpcrun
code before beginning application execution. 
To continue after attaching, use the debugger to call hpcrun_continue()
and then resume execution. 
.PP
.TP
\fB\-dd\fP \fIflag\fP, \fB\-\-dynamic\-debug\fP \fIflag\fP
 Enable the flag flag,
causing hpcrun
to log debug messages guarded with that flag 
during execution. 
A list of dynamic debug flags can be found in HPCToolkit\&'s source code 
in the file src/tool/hpcrun/messages/messages.flag\-defns\&.
Note that not all flags are meaningful on all architectures. 
The special value ALL
enables all debug flags. 
.br
Caution: turning on debug flags produces many log messages, 
often dramatically slowing the application and potentially distorting the measured profile. 
.PP
.TP
\fB\-md\fP, \fB\-\-monitor\-debug\fP
 Enable debug tracing of libmonitor,
the hpcrun
subsystem which implements process/thread control. 
.PP
.SH ENVIRONMENT VARIABLES

To function correctly, hpcrun
must know the location of the HPCToolkit
top\-level installation directory so that it can access toolkit components located 
in its lib
and libexec
subdirectories. 
Under most circumstances, hpcrun
requires no special environment variable settings. 
.PP
There are two situations, however, where hpcrun
\fImust\fP
consult the HPCTOOLKIT environment variable to determine the location 
of the top\-level installation directory: 
.PP
.TP
.B *
On some systems, parallel job launchers (e.g., Cray\&'s aprun) \fIcopy\fP the
hpcrun
script to a different location. For hpcrun
to know 
the location of its top\-level installation directory, 
you must set the HPCTOOLKIT environment variable to the 
top\-level installation directory. 
.TP
.B *
If you launch hpcrun
script via a file system link, 
you must set HPCTOOLKIT for the same reason. 
.PP
.SH LAUNCHING

.PP
When sampling with native events, by default hpcrun will profile using perf events. 
To force HPCToolkit to use PAPI (assuming it\&'s available) instead of perf events, one 
must prefix the event with \&'papi::\&'
as follows: 
.PP
.Vb
hpcrun \-e papi::CYCLES
.Ve
.PP
For PAPI presets, there is no need to prefix the event with \&'papi::\&'\&. For instance it is 
sufficient to specify PAPI_TOT_CYC
event without any prefix to profile using PAPI. 
.PP
To sample an execution 100 times per second (frequency\-based sampling) counting 
CYCLES and 100 times a second counting INSTRUCTIONS: 
.Vb
hpcrun \-e CYCLES@f100 \-e INSTRUCTIONS@f100 ...
.Ve
.PP
To sample an execution every 1,000,000 cycles and every 1,000,000 instructions using 
period\-based sampling: 
.Vb
hpcrun \-e CYCLES@1000000 \-e INSTRUCTIONS@1000000 ...
.Ve
By default, hpcrun will use frequency\-based sampling with the rate 300 samples per 
second per event type. Hence the following command will cause HPCToolkit to sample 
CYCLES at 300 samples per second and INSTRUCTIONS at 300 samples per second: 
.Vb
hpcrun \-e CYCLES \-e INSTRUCTIONS ...
.Ve
One can a different default rate using the \-c option. The command below will sample 
CYCLES at 200 samples per second and INSTRUCTIONS at 200 samples per second: 
.Vb
hpcrun \-c f200 \-e CYCLES \-e INSTRUCTIONS ...
.Ve
.PP
.SH EXAMPLES

.PP
Assume we wish to profile the application zoo\&.
The following examples lists some useful events for different processor architectures. 
.PP
.TP
.B *
hpcrun \-e CYCLES \-e INSTRUCTIONS zoo
.TP
.B *
hpcrun \-e REALTIME@5000 zoo
.TP
.B *
hpcrun \-e DC_L2_REFILL@1300013 \-e PAPI_L2_DCM@510011 \-e PAPI_STL_ICY@5300013 \-e PAPI_TOT_CYC@13000019 zoo
.TP
.B *
hpcrun \-e PAPI_L2_DCM@510011 \-e PAPI_TLB_DM@510013 \-e PAPI_STL_ICY@5300013 \-e PAPI_TOT_CYC@13000019 zoo
.PP
.SH NOTES

.PP
.SS SAMPLE SOURCES
.PP
hpcrun
uses Linux perf_events (default on Linux platform) and optionally the PAPI library to provide access to hardware performance counter events. 
It is important to note that on most out\-of\-order pipelined architectures, a hardware counter interrupt is not precisely attributed to the instruction that induced the counter to overflow. 
The gap is commonly 50\-70 instructions. 
This means that one should not assume that aggregation at the source line level is fully precise. 
(E.g., if a L1 D\-cache miss is attributed to a statement that has been compiled to register\-only operations, assume the miss is attributed to a nearby load.) 
However, aggregation at the procedure and loop level is reliable. 
.PP
.SS Linux perf_events Interface
.PP
Linux perf_events
provides a powerful interface that supports 
measurement of both application execution and kernel activity. 
Using 
perf_events,
one can measure both hardware and software events. 
Using a processor\&'s hardware performance monitoring unit (PMU), the 
perf_events
interface can measure an execution using any hardware counter 
supported by the PMU. Examples of hardware events include cycles, instructions 
completed, cache misses, and stall cycles. Using instrumentation built in to the Linux kernel, 
the perf_events
interface can measure software events. Examples of software events include page 
faults, context switches, and CPU migrations. 
.PP
HPCToolkit uses libpfm4 to translate from an event name string to an event code recognized by the kernel. 
An event name is case insensitive and is defined as followed: 
.Vb
[pmu::][event_name][:unit_mask][:modifier|:modifier=val] 
.Ve
.PP
.TP
.B *
\fBpmu\fP\&. Optional name of the PMU (group of events) to which the event belongs to. This is useful to disambiguate events in case events from difference sources have the same name. If no pmu is specified, the first match event is used.
.TP
.B *
\fBevent_name\fP\&. The name of the event. It must be the complete name, partial matches are not accepted.
.TP
.B *
\fBunit_mask\fP\&. This designate an optional sub\-events. Some events can be refined using sub\-events. An event may have multiple unit masks and it is possible to combine them (for some events) by repeating :unit_mask pattern.
.TP
.B *
\fBmodifier\fP\&. A modifier is an optional filter which modifies how the event counts. Modifiers have a type and a value specified after the equal sign.
For boolean type modifiers, without specifying the value, the presence of the modifier is interpreted as meaning true. Events may support multiple modifiers, by repeating the :modifier|:modifier=val
pattern. 
.TP
.B *
\fBprecise_ip\fP\&. For some events, it is possible to control the amount of skid.
Skid is a measure of how many instructions may execute between an event and the PC where the event is reported. 
Smaller skid enables more accurate attribution of events to instructions. Without a skid modifier, hpcrun allows arbitrary skid because some architectures 
don\&'t support anything more precise. One may optionally specify one of the following as a skid modifier: 
.RS
.TP
.B *
:p : a sample must have constant skid. 
.TP
.B *
:pp : a sample is requested to have 0 skid. 
.TP
.B *
:ppp : a sample must have 0 skid. 
.TP
.B *
:P : autodetect the least skid possible. 
.RE
.RS
.PP
NOTE: If the kernel or the hardware does not support the specified value of the skid, no error message will be reported 
but no samples will be delivered. 
.RE
.PP
.RE
.PP
Some capabilities of HPCToolkit\&'s perf_events
Interface include: 
.RE
.TP
.B *
\fBFrequency\-based sampling.\fP
Rather than picking a sample period for a hardware counter, 
the Linux perf_events
interface enables one to specify the desired sampling frequency 
and have the kernel automatically select and adjust the period 
to try to achieve the desired sampling frequency. 
To use frequency\-based sampling, one can specify the sampling rate 
for an event as the desired number of samples per second 
by prefixing the rate with the letter “f”. 
.PP
.TP
.B *
\fBMultiplexing.\fP
Using multiplexing enables one to monitor more events 
in a single execution than the number of hardware counters a processor 
can support for each thread. The number of events that can be monitored in 
a single execution is only limited by the maximum number of concurrent 
events that the kernel will allow a user to multiplex using the 
perf_events
interface. 
.PP
When more events are specified than can be monitored simultaneously 
using a thread\&'s hardware counters, 
the kernel will employ multiplexing and divide 
the set of events to be monitored into groups, monitor only one group 
of events at a time, and cycle repeatedly through the groups 
as a program executes. 
.PP
.TP
.B *
\fBThread blocking.\fP When a program executes,
a thread may block waiting for the kernel to complete some operation on its behalf. 
Example operations include waiting for a read
operation to complete or having the 
kernel service a page fault or zero\-fill a page. On systems running Linux 4.3 or newer, one can use the perf_events
sample source to monitor how much time a thread is blocked and where the blocking occurs. To measure 
the time a thread spends blocked, one can profile with BLOCKTIME event and 
another time\-based event, such as CYCLES\&. The BLOCKTIME event shouldn\&'t have any frequency or period specified, whereas CYCLES should have a frequency or period specified. 
.PP
.SS PAPI Interface (optional)
The PAPI library supports a large collection of hardware counter events. 
Some events have standard names across all platforms, e.g. PAPI_TOT_CYC, the event that measures total cycles. 
In addition to events whose names begin with the PAPI_ prefix, platforms also provide access to a set of native events with names that are specific to the platform\&'s processor. 
A complete list of events supported by the PAPI library for your platform may be obtained by using the \-\-list\-events
option. 
Any event whose name begins with the PAPI_ prefix that is listed as "Profilable" can be used as an event in a sampling source provided it does not conflict with another event. 
.PP
The rules of thumb for selecting an appropriate set of events and their associated periods are complex. 
.PP
.TP
.B *
\fBChoosing sampling events.\fP
Some PAPI events are not profilable because of PAPI implementation details. 
Also, PAPI\&'s standard event list may not cover an architectural feature you are interested in. 
In such cases, it is necessary to resort to native events. 
In many cases, you will have to consult the architecture\&'s manual to fully understand what the event means: there is no standard event list or naming scheme and events sometimes have unusual meanings. 
.PP
.TP
.B *
\fBNumber of sampling events.\fP
hpcrun
does not multiplex hardware counters for events measured using PAPI. (Events measured using the Linux 
perf interface will be multiplexed automatically.) 
Without multiplexing, the number of events that you may use to profile a single execution 
is limited by your architecture\&'s performance monitoring unit. 
Note that some architectures hard\-wire one or more counters to a specific event (such as cycles). 
.PP
.TP
.B *
\fBChoosing sampling periods.\fP
The key requirement in choosing sampling periods is that you obtain enough samples to provide statistical significance. 
We usually recommend a sampling rate between 100s\-1000s of samples per second. 
This usually only produces 1\-5% execution time overhead. 
.PP
Choosing sampling rates depends on the architecture and sometimes the application. 
.PP
Choosing periods for cycle and instruction\-related events are usually easy. 
Cycles directly relates to the clock speed. 
Instruction\-related events relates to the issue rate and width. 
.PP
Choosing periods for other events seems harder because different applications uses resources differently. 
For example, some applications are memory intensive and others are not. 
However, if the goal is to identify rate\-limiting factors of the architecture, then it is not necessary to consider the application. 
For example, if the goal is to determine whether L2 D\-cache latency is a limiting factor, then it is only necessary to work backward from the architecture\&'s specifications to determine what number of L2 D\-cache misses per second would be problematic. 
.PP
.TP
.B *
\fBArchitectural event conflicts.\fP
With some performance monitoring units, certain events may not be concurrently used with other events. 
.PP
.SS System itimer (WALLCLOCK).
On Linux systems, the kernel will not deliver itimer interrupts faster than the unit of a jiffy, which defaults to 4 milliseconds; see the itimer man page. 
One can configure the kernel to use a value as small as 1 millisecond, but it is unlikely the kernel will actually deliver itimer signals at that rate when a period of 1000 microseconds is requested. 
.PP
However, on Linux one can get quite close to the kernel Hz rate by setting the itimer interval to something less than the Hz rate. 
For example, if the Hz rate is 1000 microseconds, one can use 500 microseconds (or just 1) and obtain about 999 interrupts per second. 
.PP
.SS PLATFORM\-SPECIFIC NOTES
.SS Cray Systems
When using dynamically linked binaries on Cray systems, you 
should add the HPCTOOLKIT environment variable to your launch 
script. Set HPCTOOLKIT to the top\-level HPCToolkit install 
prefix (the directory containing the bin,
lib
and 
libexec
subdirectories) and export it to the environment. This is 
only needed for running dynamically linked binaries. For example: 
.PP
.Vb
#!/bin/sh
#PBS \-l mppwidth=#nodes
#PBS \-l walltime=00:30:00
#PBS \-V

export HPCTOOLKIT=/path/to/hpctoolkit/install/directory

    ...Rest of Script...
.Ve
.PP
If HPCTOOLKIT is not set, you may see errors such as the 
following in your job\&'s error log. 
.PP
.Vb
/var/spool/alps/103526/hpcrun: Unable to find HPCTOOLKIT root directory.
Please set HPCTOOLKIT to the install prefix, either in this script,
or in your environment, and try again.
.Ve
.PP
The problem is that the Cray ALPS job launcher copies the hpcrun
script to a directory somewhere below /var/spool/alps/
and runs 
it from there. By moving hpcrun
to a different directory, this 
breaks hpcrun\&'s
default method for finding HPCToolkit\&'s top\-level 
installation directory. 
The solution is to add HPCTOOLKIT to your environment so that 
hpcrun
can find HPCToolkit\&'s top\-level installation directory. 
.PP
.SS MISCELLANEOUS
.PP
.TP
.B *
hpcrun uses preloaded shared libraries to initiate profiling. For this reason, it cannot be used to profile setuid programs.
.TP
.B *
hpcrun may not be able to profile programs that themselves use preloading.
.PP
.SH SEE ALSO

.PP
\fIhpctoolkit\fP(1)
\&.
.br
\fIhpclink\fP(1)
\&.
.PP
.SH VERSION

.PP
Version: develop
.PP
.SH LICENSE AND COPYRIGHT

.PP
.TP
Copyright 
(C)2002\-2019, Rice University. 
.TP
License 
See README.License\&.
.PP
.SH AUTHORS

.PP
Rice University\&'s HPCToolkit Research Group 
.br
Email: \fBhpctoolkit\-forum =at= rice.edu\fP
.br
WWW: \fBhttp://hpctoolkit.org\fP\&.
.PP
.\" NOTE: This file is generated, DO NOT EDIT.
